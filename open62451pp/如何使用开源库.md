# 如何使用开源库

两种方法:
- 编译源文件并生成库，安装到`/usr/local` 这样可以直接使用`find_package`链接
- 以子模块的形式将源码包含在项目当中
***


## 1. 基础环境配置

1. 更新并安装基本工具与依赖（含 gcc-11 / g++-11）：

```bash
sudo apt update
sudo apt install -y build-essential git cmake ninja-build pkg-config python3 python3-pip \
                    libssl-dev ccache

# 安装 gcc-11 / g++-11（如果你已经有 gcc11 可跳过）
# Ubuntu 20.04 默认自带 GCC 9，你需要添加 官方 Toolchain PPA 才能装新版。
# 更新包索引
sudo apt update
sudo apt upgrade -y

# 添加 gcc 官方仓库
sudo add-apt-repository ppa:ubuntu-toolchain-r/test -y
sudo apt update

# 安装 gcc/g++ 11
sudo apt install -y gcc-11 g++-11

# 查看版本
gcc-11 --version
g++-11 --version

# 把系统默认的 gcc 切换到 11
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 11
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 11
# 手动选择 gcc 版本
sudo update-alternatives --config gcc
sudo update-alternatives --config g++
#确认
gcc --version
g++ --version
```

------

## 2. 获取 open62541pp 源码（带子模块）

```bash
cd ~/src
git clone --recursive https://github.com/open62541pp/open62541pp.git
cd open62541pp
# 确保子模块也更新（如果没用 --recursive）
git submodule update --init --recursive
```

（open62541pp README 推荐用 `--recursive`，仓库包含 open62541 子模块并且可以选择内部 open62541 构建）([GitHub](https://github.com/open62541pp/open62541pp))

------

## 3. 构建 open62541pp（生成库）

下面的命令把 open62541pp 和内嵌的 open62541 一起构建。我们用 `UAPP_INTERNAL_OPEN62541=ON`（表示使用仓库内的 open62541 子模块）。

```bash
# 在仓库目录内
mkdir -p build && cd build

# 如果需要指定 gcc-11 / g++-11（推荐）
cmake -DCMAKE_BUILD_TYPE=Release \
      -DUAPP_INTERNAL_OPEN62541=ON \
      -DCMAKE_C_COMPILER=/usr/bin/gcc-11 \
      -DCMAKE_CXX_COMPILER=/usr/bin/g++-11 \
      ..

# 使用 make 或 ninja（上面装了 ninja，可用 -G Ninja）
cmake --build . -- -j$(nproc)
# or with config:
# cmake --build . --config Release
```

解释：

- `UAPP_INTERNAL_OPEN62541=ON`：使用仓库内集成的 open62541 子模块构建（可选，你也可以用系统已安装的 open62541）；open62541pp 支持两种方式。
- 可以使用`BUILD_SHARED_LIBS=ON`：告诉 CMake 默认把 `add_library()` 生成 shared（open62541 会以 .so 形式构建）

**构建完成后**，你会在 `build` 目录下看到生成的库与可执行文件（examples）。如果你想把库安装到系统路径（以便后续 `find_package` 找到），执行：

```bash
sudo cmake --install .
```

（这会把 `open62541ppConfig.cmake` 安装到系统 CMake 路径，使 find_package 生效。）([GitHub](https://github.com/open62541pp/open62541pp))

最后查看库文件是否存在

```bash
ls /usr/local/lib | grep open62541
```

## 4. 以 submodule形式嵌入到工程内
这个方案的要点：

- 把 `open62541pp` 作为子模块放到 `extern/open62541pp`，然后在主工程里用 `add_subdirectory(extern/open62541pp)` 一并构建并链接（CMake 会生成 `open62541pp::open62541pp` target）。
- 我同时给出如何用 **静态（默认）或共享（.so）** 两种构建方式（通过设置 `BUILD_SHARED_LIBS`）。

### 1. 初始化工程并添加子模块（在终端执行）

```bash
# 在你的工作目录下创建项目
mkdir -p ~/opc_ua/opc_demo_submodule
cd ~/opc_ua/opc_demo_submodule

# 初始化为 git 仓库（可选）
git init

# 添加 open62541pp 子模块（递归拉取子模块）
git submodule add --recursive https://github.com/open62541pp/open62541pp.git extern/open62541pp

# 如果子模块已经添加但未初始化，运行：
# git submodule update --init --recursive
```

------

### 2. 项目结构（执行完上面后应类似）

```
opc_demo_submodule/
├── CMakeLists.txt        # 顶层 CMake（下文给出）
├── server_demo.cpp       # 服务器源（下文给出）
├── client_demo.cpp       # 客户端源（下文给出）
└── extern/
    └── open62541pp/      # git submodule（源码）
```

------


## 5. 测试

### 1） 生成库文件并安装的形式

在你的 demo 项目目录（比如 `~/opc_ua/demo`）写下 `server_demo.cpp` 与 `client_demo.cpp`。这里给出 `CMakeLists.txt`（使用 `find_package`）：

```cmake
cmake_minimum_required(VERSION 3.16)
project(opc_shared_demo CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_EXTENSIONS OFF)

find_package(open62541pp CONFIG REQUIRED)

add_executable(server_demo server_demo.cpp)
target_link_libraries(server_demo PRIVATE open62541pp::open62541pp)

add_executable(client_demo client_demo.cpp)
target_link_libraries(client_demo PRIVATE open62541pp::open62541pp)
```

构建步骤

```bash
mkdir -p ~/opc_ua/demo_shared/build
cd ~/opc_ua/demo_shared/build
cmake -DCMAKE_C_COMPILER=/usr/bin/gcc-11 -DCMAKE_CXX_COMPILER=/usr/bin/g++-11 ..
cmake --build . -- -j$(nproc)
```

### 2） submodule的形式

将下面内容保存为项目根目录的 `CMakeLists.txt`：

```cmake
cmake_minimum_required(VERSION 3.16)
project(opc_demo_submodule CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ---------- 可选：在这里切换生成 shared lib 或 static lib ----------
# 如果你想生成动态库（.so），将下面注释取消（ON）
# 如果想使用静态库，注释或设置为 OFF
option(OPC_BUILD_SHARED_OPEN62541PP "Build open62541pp and open62541 as shared libraries" OFF)

# 将配置传递给子模块（通过 cache 强制传递）
set(BUILD_SHARED_LIBS ${OPC_BUILD_SHARED_OPEN62541PP} CACHE BOOL "Control shared vs static" FORCE)
# open62541pp option：若你想强制使用子模块内的 open62541，打开下面（通常子模块默认会使用）
set(UAPP_INTERNAL_OPEN62541 ON CACHE BOOL "Use internal open62541 submodule" FORCE)

# （可选）显示设置编译器，如果需要用 gcc-11 / g++-11，取消下面注释并修改路径
# set(CMAKE_C_COMPILER "/usr/bin/gcc-11" CACHE STRING "" FORCE)
# set(CMAKE_CXX_COMPILER "/usr/bin/g++-11" CACHE STRING "" FORCE)

# 把子模块加入构建（确保 extern/open62541pp 已存在）
add_subdirectory(extern/open62541pp)

# 现在 open62541pp::open62541pp target 应该可用
# 创建两个可执行
add_executable(server_demo server_demo.cpp)
add_executable(client_demo client_demo.cpp)

# 链接 open62541pp target（让 CMake 管理 include 和 link）
target_link_libraries(server_demo PRIVATE open62541pp::open62541pp)
target_link_libraries(client_demo PRIVATE open62541pp::open62541pp)

# 如果你想显示输出路径
set_target_properties(server_demo PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set_target_properties(client_demo PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
```

说明：

- `OPC_BUILD_SHARED_OPEN62541PP` 控制是否使用 shared libs；默认 `OFF`（静态）。如果要生成 `.so`，可以在 configure 时传 `-DOPC_BUILD_SHARED_OPEN62541PP=ON` 或把 `OFF` 改为 `ON`。
- `UAPP_INTERNAL_OPEN62541` 强制子模块使用内嵌的 open62541 子项目（通常建议设 ON）。

构建步骤：
```bash
mkdir -p build && cd build

# 若想用静态（默认），执行：
cmake -DCMAKE_BUILD_TYPE=Release ..

# 若你想生成动态库 (.so)，执行（示例开启 shared）：
# cmake -DCMAKE_BUILD_TYPE=Release -DOPC_BUILD_SHARED_OPEN62541PP=ON ..

# 若需要指定 gcc-11：
# cmake -DCMAKE_BUILD_TYPE=Release -DOPC_BUILD_SHARED_OPEN62541PP=ON -DCMAKE_C_COMPILER=/usr/bin/gcc-11 -DCMAKE_CXX_COMPILER=/usr/bin/g++-11 ..

cmake --build . -- -j$(nproc)
```
若使用了 shared libraries（`OPC_BUILD_SHARED_OPEN62541PP=ON`），可能需要设置运行时库路径（因为子模块生成的 .so 在 build 目录）：

```bash
export LD_LIBRARY_PATH=~/opc_ua/opc_demo_submodule/build/bin:$LD_LIBRARY_PATH
./server_demo
# 新终端
export LD_LIBRARY_PATH=~/opc_ua/opc_demo_submodule/build/bin:$LD_LIBRARY_PATH
./client_demo
```

## 6. 两种方法的区别

### 预编译库方式
- **优点**：构建速度快；适合发布和部署；库与应用解耦。  
- **缺点**：升级和维护库相对繁琐；跨平台或跨机器使用时需要重新准备库文件；修改依赖源码不方便。  

### submodule 子模块方式
- **优点**：一键构建；依赖版本固定；更方便调试和修改依赖源码；跨平台体验更好。  
- **缺点**：构建时间更长；仓库体积更大；依赖升级需要手动操作。  

------
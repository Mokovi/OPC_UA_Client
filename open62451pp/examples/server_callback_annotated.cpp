/**
 * @file server_callback_annotated.cpp
 * @brief OPC UA 服务器回调示例 - 演示如何使用定时回调和重复回调
 * 
 * 本示例展示了 open62541pp 库中回调系统的使用方法，包括：
 * 1. 创建重复执行的回调函数
 * 2. 创建定时执行的回调函数
 * 3. 动态修改回调的执行间隔
 * 4. 管理回调的生命周期
 * 5. 在服务器运行期间执行自定义逻辑
 * 
 * 功能说明：
 * - 支持重复执行的回调（按固定间隔）
 * - 支持定时执行的回调（在指定时间执行）
 * - 可以动态调整回调参数
 * - 回调与服务器事件循环集成
 */

#include <chrono>
#include <iostream>

// 包含必要的头文件
#include "open62541pp/callback.hpp"  // 回调功能
#include "open62541pp/server.hpp"    // 服务器核心功能

int main() {
    std::cout << "=== OPC UA 服务器回调示例 ===" << std::endl;
    
    // 创建 OPC UA 服务器实例
    opcua::Server server;

    // 计数器变量，用于跟踪重复回调的执行次数
    size_t counter = 0;
    
    // 设置重复回调的执行间隔（毫秒）
    const double interval = 500;  // 500 毫秒 = 0.5 秒
    
    std::cout << "正在创建重复回调，执行间隔: " << interval << "ms" << std::endl;
    
    // 创建重复执行的回调函数
    // 这个回调会按照指定的间隔重复执行
    const opcua::CallbackId id1 = opcua::addRepeatedCallback(
        server,                    // 服务器实例
        [&] {                     // 回调函数（lambda 表达式）
            ++counter;            // 增加计数器
            std::cout << "重复回调执行: " << counter << std::endl;
        },
        interval                   // 执行间隔（毫秒）
    );

    std::cout << "重复回调创建成功，回调ID: " << id1 << std::endl;

    // 创建定时执行的回调函数
    // 这个回调会在指定的时间执行一次
    std::cout << "正在创建定时回调，将在 2 秒后执行..." << std::endl;
    
    const opcua::CallbackId id2 = opcua::addTimedCallback(
        server,                    // 服务器实例
        [&] {                     // 回调函数（lambda 表达式）
            std::cout << "定时回调执行: 将重复回调的间隔加倍" << std::endl;
            
            // 动态修改重复回调的执行间隔
            // 将原来的间隔乘以 2（从 500ms 变为 1000ms）
            opcua::changeRepeatedCallbackInterval(server, id1, interval * 2);
            
            std::cout << "重复回调间隔已修改为: " << (interval * 2) << "ms" << std::endl;
        },
        opcua::DateTime::now() + std::chrono::seconds(2)  // 2 秒后执行
    );

    std::cout << "定时回调创建成功，回调ID: " << id2 << std::endl;
    
    std::cout << "\n=== 回调系统说明 ===" << std::endl;
    std::cout << "1. 重复回调 (ID: " << id1 << "): 每 " << interval << "ms 执行一次" << std::endl;
    std::cout << "2. 定时回调 (ID: " << id2 << "): 2 秒后执行一次" << std::endl;
    std::cout << "3. 定时回调执行后，重复回调的间隔将变为 " << (interval * 2) << "ms" << std::endl;
    std::cout << "4. 所有回调都与服务器事件循环集成" << std::endl;
    
    std::cout << "\n正在启动服务器..." << std::endl;
    std::cout << "观察控制台输出，可以看到回调的执行情况" << std::endl;
    std::cout << "按 Ctrl+C 停止服务器" << std::endl;

    // 启动服务器
    // 服务器运行期间，回调函数会按照设定的规则执行
    server.run();

    // 注意：以下代码实际上不会执行，因为 server.run() 会阻塞
    // 这里仅用于演示如何清理回调资源
    std::cout << "正在清理回调资源..." << std::endl;
    opcua::removeCallback(server, id1);
    opcua::removeCallback(server, id2);
    std::cout << "回调资源清理完成" << std::endl;
    
    return 0;
}

/**
 * 使用说明：
 * 
 * 1. 编译并运行此程序
 * 2. 程序将创建一个带有回调功能的 OPC UA 服务器
 * 3. 观察重复回调的定期执行
 * 4. 2 秒后定时回调执行，修改重复回调的间隔
 * 5. 按 Ctrl+C 停止服务器
 * 
 * 回调系统工作原理：
 * 
 * 1. 重复回调 (addRepeatedCallback)：
 *    - 按照指定的时间间隔重复执行
 *    - 间隔以毫秒为单位
 *    - 与服务器事件循环同步
 *    - 可以动态修改执行间隔
 * 
 * 2. 定时回调 (addTimedCallback)：
 *    - 在指定的时间点执行一次
 *    - 使用 DateTime 指定执行时间
 *    - 支持相对时间和绝对时间
 *    - 执行后自动清理
 * 
 * 3. 回调管理：
 *    - 每个回调都有唯一的 ID
 *    - 可以动态修改回调参数
 *    - 可以手动删除回调
 *    - 服务器关闭时自动清理
 * 
 * 回调类型说明：
 * 
 * 1. 重复回调：
 *    - 用途：定期执行的任务
 *    - 示例：数据采集、状态更新、心跳检测
 *    - 特点：持续执行，可配置间隔
 * 
 * 2. 定时回调：
 *    - 用途：一次性延迟任务
 *    - 示例：延迟初始化、超时处理、计划任务
 *    - 特点：执行一次后自动清理
 * 
 * 回调函数设计：
 * 
 * 1. 函数签名：
 *    - 使用 lambda 表达式
 *    - 无参数，无返回值
 *    - 通过捕获列表访问外部变量
 * 
 * 2. 执行时间：
 *    - 回调在服务器事件循环中执行
 *    - 避免长时间阻塞
 *    - 考虑性能影响
 * 
 * 3. 错误处理：
 *    - 回调中的异常应该被捕获
 *    - 避免回调失败影响服务器
 *    - 记录错误日志
 * 
 * 扩展建议：
 * 
 * 1. 添加更多回调类型：
 *    - 条件回调（满足条件时执行）
 *    - 链式回调（回调触发其他回调）
 *    - 批量回调（一次执行多个任务）
 * 
 * 2. 改进回调管理：
 *    - 回调分组和分类
 *    - 回调优先级管理
 *    - 回调依赖关系处理
 * 
 * 3. 添加回调监控：
 *    - 执行次数统计
 *    - 执行时间监控
 *    - 错误率统计
 * 
 * 4. 实现回调配置：
 *    - 从配置文件读取参数
 *    - 运行时动态配置
 *    - 回调参数验证
 * 
 * 注意事项：
 * 
 * - 回调函数应该快速执行，避免阻塞
 * - 长时间运行的任务应该使用异步处理
 * - 回调中的异常应该被适当处理
 * - 考虑回调的内存和资源管理
 * 
 * 性能考虑：
 * 
 * - 回调频率影响服务器性能
 * - 回调执行时间影响响应性
 * - 大量回调可能影响内存使用
 * - 考虑使用回调池优化性能
 * 
 * 安全考虑：
 * 
 * - 回调函数应该有适当的访问控制
 * - 避免在回调中执行危险操作
 * - 验证回调参数的有效性
 * - 考虑回调的审计和日志记录
 * 
 * 实际应用场景：
 * 
 * 1. 数据采集系统：
 *    - 定期读取传感器数据
 *    - 更新设备状态
 *    - 执行数据清理任务
 * 
 * 2. 监控系统：
 *    - 定期检查系统健康状态
 *    - 生成性能报告
 *    - 执行维护任务
 * 
 * 3. 通信系统：
 *    - 定期发送心跳消息
 *    - 检查连接状态
 *    - 执行重连逻辑
 */
